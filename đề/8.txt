Đọc ảnh mầu apple.jpg vào biến ma trận I.
1. (2 điểm) Hiển thị kênh R của ảnh I.
2. (4 điểm) Chuyển ảnh mầu I sang ảnh đa cấp xám (grayscale) theo công thức xác định mức độ xám từ tổ hợp các thành phần mầu (r,g,b) theo tỷ lệ (0.39,0.5,0.11), được ma trận ảnh Ig. Hiển thị ảnh Ig. Xác định mức xám trung bình của ảnh Ig.
3. (1 điểm) Xác định ma trận gradient theo hướng x của Ig sử dụng toán tử Sobel và hiển thị ma trận kết quả.
4. (1 điểm) Lấy biên của ảnh Ig theo phương pháp Canny được ảnh biên Ie là ảnh nhị phân nền đen. Kiểm tra các điểm ảnh của pixel có tọa độ dòng  y=100, cột x=120 có phải là điểm biên của Ig theo phương pháp dò biên Canny.
5. (1.5 điểm). Nhị phân ảnh Ig theo ngưỡng Otsu được ảnh nhị phân nền đen Ib. Xác đường contour của ảnh Ib có diện tích lớn nhất. Vẽ đường contour tìm được trên lên ảnh gốc I.

import cv2
import numpy as np

I = cv2.imread("anh2.jpg")

cv2.imshow("Anh goc",I)

Ig=0.39*I[:,:,2] + 0.5*I[:,:,1]+0.11*I[:,:,0]
Ig_show = Ig.astype('uint8')

cv2.imshow("Gray ",Ig_show)
print("Muc xam trung binh",np.mean(Ig_show))

IgradientX = cv2.Sobel(Ig, cv2.CV_64F, 1, 0, 3)
# cv2.imshow("Sobel X",IgradientX)
print("Ma tran sobel X",IgradientX)

y = 100
x = 120

Ie = cv2.Canny(I,0,255)


if Ie[y][x] == 255:
    print("Điểm ảnh Is(y="+str(y)+",x="+str(x)+") là điểm điểm biên theo Canny")
else:
    print("Điểm ảnh Is(y="+str(y)+",x="+str(x)+") không là điểm điểm biên theo Canny")

# chuyển đổi ảnh Ig sang ảnh nhị phân với ngưỡng tự động Otsu
thresh, Ib = cv2.threshold(Ig_show, 0, 255, cv2.THRESH_OTSU) #theo ngưỡng OTSU, OpenCV nó cung cấp ngưỡng Otsu tính tự động ngưỡng
cv2.imshow("Nhi phan nguong Ostu",Ib)
print (thresh)

contours, _ = cv2.findContours(Ib, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

max_area = 0.0
contour_max = []
for cnt in contours:
    if max_area <= cv2.contourArea(cnt):
        max_area = cv2.contourArea(cnt)
        contour_max = cnt
cv2.drawContours(Ib, contours, -1, (0, 0, 255), 2) #đỏ

cv2.imshow('dien tich contour', I) #Xanh lá

cv2.waitKey()
